// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Err = /* @__PURE__ */Caml_exceptions.create("Seq.Err");

function force(cons) {
  var tail = cons.tail;
  var tmp;
  tmp = tail.TAG === /* Forced */0 ? ({
        TAG: /* Forced */0,
        _0: tail._0
      }) : ({
        TAG: /* Forced */0,
        _0: Curry._1(tail._0, undefined)
      });
  cons.tail = tmp;
  return cons;
}

function car(cons) {
  return cons.head;
}

function cdr(cons) {
  var match = force(cons);
  var tail = match.tail;
  if (tail.TAG === /* Forced */0) {
    return tail._0;
  }
  throw {
        RE_EXN_ID: Err,
        _1: "cdr force unexpected error.",
        Error: new Error()
      };
}

function cons(head, tail) {
  return /* Cons */{
          _0: {
            head: head,
            tail: tail
          }
        };
}

function make(thunk, head) {
  if (thunk !== undefined) {
    return /* Cons */{
            _0: {
              head: head,
              tail: {
                TAG: /* Lazy */1,
                _0: thunk
              }
            }
          };
  } else {
    return /* Cons */{
            _0: {
              head: head,
              tail: {
                TAG: /* Forced */0,
                _0: /* Nil */0
              }
            }
          };
  }
}

function equal(_seq1, _seq2) {
  while(true) {
    var seq2 = _seq2;
    var seq1 = _seq1;
    if (!seq1) {
      if (seq2) {
        return false;
      } else {
        return true;
      }
    }
    if (!seq2) {
      return false;
    }
    var c2 = seq2._0;
    var c1 = seq1._0;
    if (!Caml_obj.caml_equal(c1.head, c2.head)) {
      return false;
    }
    _seq2 = cdr(c2);
    _seq1 = cdr(c1);
    continue ;
  };
}

function map(seq, f) {
  if (!seq) {
    return /* Nil */0;
  }
  var c = seq._0;
  var head = Curry._1(f, c.head);
  return /* Cons */{
          _0: {
            head: head,
            tail: {
              TAG: /* Lazy */1,
              _0: (function (param) {
                  return map(cdr(c), f);
                })
            }
          }
        };
}

function append(seq, thunk) {
  if (!seq) {
    return Curry._1(thunk, undefined);
  }
  var c = seq._0;
  return /* Cons */{
          _0: {
            head: c.head,
            tail: {
              TAG: /* Lazy */1,
              _0: (function (param) {
                  return append(cdr(c), thunk);
                })
            }
          }
        };
}

function countForced(seq) {
  var _index = 0;
  var _s = seq;
  while(true) {
    var s = _s;
    var index = _index;
    if (!s) {
      return [
              index,
              true
            ];
    }
    var tail = s._0.tail;
    if (tail.TAG !== /* Forced */0) {
      return [
              index + 1 | 0,
              false
            ];
    }
    _s = tail._0;
    _index = index + 1 | 0;
    continue ;
  };
}

function take(seq, n) {
  if (n === 0) {
    return /* Nil */0;
  }
  if (!seq) {
    return /* Nil */0;
  }
  var c = seq._0;
  var tail = {
    TAG: /* Forced */0,
    _0: take(cdr(c), n - 1 | 0)
  };
  return /* Cons */{
          _0: {
            head: c.head,
            tail: tail
          }
        };
}

function lazyTake(seq, n) {
  if (n === 0) {
    return /* Nil */0;
  }
  if (!seq) {
    return /* Nil */0;
  }
  var c = seq._0;
  return /* Cons */{
          _0: {
            head: c.head,
            tail: {
              TAG: /* Lazy */1,
              _0: (function (param) {
                  return lazyTake(cdr(c), n - 1 | 0);
                })
            }
          }
        };
}

function takeWhile(seq, test) {
  var count = {
    contents: 0
  };
  var loop = function (input) {
    if (!input) {
      return /* Nil */0;
    }
    var c = input._0;
    if (!Curry._1(test, c.head)) {
      return /* Nil */0;
    }
    count.contents = count.contents + 1 | 0;
    var tail = {
      TAG: /* Forced */0,
      _0: loop(cdr(c))
    };
    return /* Cons */{
            _0: {
              head: c.head,
              tail: tail
            }
          };
  };
  var l = loop(seq);
  return [
          count.contents,
          l
        ];
}

function drop(_seq, _n) {
  while(true) {
    var n = _n;
    var seq = _seq;
    if (n === 0) {
      return seq;
    }
    if (!seq) {
      return /* Nil */0;
    }
    _n = n - 1 | 0;
    _seq = cdr(seq._0);
    continue ;
  };
}

function dropWhile(seq, test) {
  var _count = 0;
  var _input = seq;
  while(true) {
    var input = _input;
    var count = _count;
    if (!input) {
      return [
              0,
              /* Nil */0
            ];
    }
    var c = input._0;
    if (!Curry._1(test, c.head)) {
      return [
              count,
              input
            ];
    }
    _input = cdr(c);
    _count = count + 1 | 0;
    continue ;
  };
}

function reduce(_seq, _n, f, _acc) {
  while(true) {
    var acc = _acc;
    var n = _n;
    var seq = _seq;
    if (n === 0) {
      return [
              acc,
              seq
            ];
    }
    if (!seq) {
      return [
              acc,
              seq
            ];
    }
    var c = seq._0;
    _acc = Curry._2(f, acc, c.head);
    _n = n - 1 | 0;
    _seq = cdr(c);
    continue ;
  };
}

function reduceWhile(seq, test, f, acc) {
  var _input = seq;
  var _acc = acc;
  var _index = 0;
  while(true) {
    var index = _index;
    var acc$1 = _acc;
    var input = _input;
    if (!input) {
      return [
              acc$1,
              index,
              input
            ];
    }
    var c = input._0;
    if (!Curry._1(test, c.head)) {
      return [
              acc$1,
              index,
              input
            ];
    }
    _index = index + 1 | 0;
    _acc = Curry._2(f, acc$1, c.head);
    _input = cdr(c);
    continue ;
  };
}

function reduceWhile2(seq, f, acc) {
  var _input = seq;
  var _acc = acc;
  var _index = 0;
  while(true) {
    var index = _index;
    var acc$1 = _acc;
    var input = _input;
    if (!input) {
      return [
              acc$1,
              index,
              input
            ];
    }
    var c = input._0;
    var acc$2 = Curry._3(f, acc$1, c.head, index);
    if (acc$2 === undefined) {
      return [
              acc$1,
              index,
              input
            ];
    }
    _index = index + 1 | 0;
    _acc = Caml_option.valFromOption(acc$2);
    _input = cdr(c);
    continue ;
  };
}

function match(equal, seq, lst) {
  var eq = equal !== undefined ? equal : Caml_obj.caml_equal;
  var _index = 0;
  var _input = seq;
  var _lst = lst;
  while(true) {
    var lst$1 = _lst;
    var input = _input;
    var index = _index;
    if (!lst$1) {
      return index;
    }
    if (!input) {
      return index;
    }
    var c0 = input._0;
    var c1 = lst$1._0;
    if (!Curry._2(eq, c0.head, c1.head)) {
      return index;
    }
    _lst = cdr(c1);
    _input = cdr(c0);
    _index = index + 1 | 0;
    continue ;
  };
}

function takeListCount(seq, n) {
  var count = {
    contents: 0
  };
  var loop = function (seq, n, got) {
    if (n === 0) {
      count.contents = got;
      return /* [] */0;
    }
    if (seq) {
      var c = seq._0;
      return {
              hd: c.head,
              tl: loop(cdr(c), n - 1 | 0, got + 1 | 0)
            };
    }
    count.contents = got;
    return /* [] */0;
  };
  var l = loop(seq, n, 0);
  return [
          count.contents,
          l
        ];
}

function fromList(lst) {
  if (!lst) {
    return /* Nil */0;
  }
  var rest = lst.tl;
  var a = lst.hd;
  if (rest) {
    return /* Cons */{
            _0: {
              head: a,
              tail: {
                TAG: /* Lazy */1,
                _0: (function (param) {
                    return fromList(rest);
                  })
              }
            }
          };
  } else {
    return /* Cons */{
            _0: {
              head: a,
              tail: {
                TAG: /* Forced */0,
                _0: /* Nil */0
              }
            }
          };
  }
}

function fromArrayInPlace(arr) {
  var gen = function (param) {
    var len = arr.length;
    if (len !== 1) {
      if (len === 0) {
        return /* Nil */0;
      }
      var a = arr.shift();
      if (a !== undefined) {
        return /* Cons */{
                _0: {
                  head: a,
                  tail: {
                    TAG: /* Lazy */1,
                    _0: gen
                  }
                }
              };
      }
      throw {
            RE_EXN_ID: Err,
            _1: "unreachable",
            Error: new Error()
          };
    }
    var a$1 = arr[0];
    return /* Cons */{
            _0: {
              head: a$1,
              tail: {
                TAG: /* Forced */0,
                _0: /* Nil */0
              }
            }
          };
  };
  return gen(undefined);
}

function fromArray(arr) {
  var gen = function (index) {
    var a = Belt_Array.get(arr, index);
    if (a !== undefined) {
      return /* Cons */{
              _0: {
                head: Caml_option.valFromOption(a),
                tail: {
                  TAG: /* Lazy */1,
                  _0: (function (param) {
                      return gen(index + 1 | 0);
                    })
                }
              }
            };
    } else {
      return /* Nil */0;
    }
  };
  return gen(0);
}

function fromString(str) {
  var gen = function (index) {
    var c = str.charAt(index);
    if (c === "") {
      return /* Nil */0;
    } else {
      return /* Cons */{
              _0: {
                head: c,
                tail: {
                  TAG: /* Lazy */1,
                  _0: (function (param) {
                      return gen(index + 1 | 0);
                    })
                }
              }
            };
    }
  };
  return gen(0);
}

exports.Err = Err;
exports.force = force;
exports.car = car;
exports.cdr = cdr;
exports.cons = cons;
exports.make = make;
exports.equal = equal;
exports.map = map;
exports.append = append;
exports.countForced = countForced;
exports.take = take;
exports.lazyTake = lazyTake;
exports.takeWhile = takeWhile;
exports.drop = drop;
exports.dropWhile = dropWhile;
exports.reduce = reduce;
exports.reduceWhile = reduceWhile;
exports.reduceWhile2 = reduceWhile2;
exports.match = match;
exports.takeListCount = takeListCount;
exports.fromList = fromList;
exports.fromArrayInPlace = fromArrayInPlace;
exports.fromArray = fromArray;
exports.fromString = fromString;
/* No side effect */
